# -*- coding: utf-8 -*-
"""Submision.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BdiS0uAik_ALE5FdGSywMO9wOeuw5axt

# **Studi Predictive Analytics : Harga penjualan Mobil Yang telah dipakai (Bekas)**

Model yang dibuat menggunakan tiga model yaitu K-Nearest Neighbor, Random Forest, Boosting Algorithm. Kita akan memprediksi harga penjualan mobil berdasarkan berdasarkan beberapa fitur yang tersedia. Dengan ketiga algoritma model yg disebutkan, selanjutnya akan dianalisis algoritma mana yang memberikan hasil prediksi terbaik.


## **Time Series**

Time series dapat dipahami sebagai kumpulan nilai yang tersusun secara runtut dalam rentang waktu tertentu.

## **Dataset**

Dataset yang digunakan menggunakan dataset Vehicle dataset yaitu CAR DETAILS FROM CAR DEKHO.csv yang bisa ditemukan di https://www.kaggle.com/datasets/nehalbirla/vehicle-dataset-from-cardekho Dataset ini memiliki 14340 baris dan 8 columns kolom. Kolom yang terdapat pada dataset ini yakni name (nama/jenis mobil), year(Tahun rilis mobil), selling_price(Harga penjualan), km_driven(Total angka kilometer yang telah ditempuh), fuel(Jenis bahan bakar), seller_type(Tipe penjual), transmission(jenis transmisi), owner(bekas pemilik ke - ) atau mobil bekas test percobaan.
"""

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
# %matplotlib inline
import seaborn as sns
from sklearn.preprocessing import  OneHotEncoder
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler

from sklearn.metrics import mean_squared_error
from sklearn.neighbors import KNeighborsRegressor
from sklearn.ensemble import RandomForestRegressor
from sklearn.ensemble import AdaBoostRegressor

"""## **Membaca data menggunakan Pandas**

Disini kita dataset akan dibaca dengan menggunakan library pandas yaitu car_data.csv yg sebelumnya bernama CAR DETAILS FROM CAR DEKHO. pandas membaca data frame car_data.csv melalui link path google drive yang disimpan di dalam variabel url.
"""

url = '/content/drive/MyDrive/Dicoding/way/Mchine learning terapan/car_data.csv'
cars = pd.read_csv(url)
cars

"""## **Melihat tipe data**

Dengan menggunakan method info, kita bisa melihat informasi dan tipe data. Terdapat 4340 non-null  yang artinya tidak ada data kosong/missing value. Terdapat pula tipe data object/kategorik seperti: name, fuel, seller_type,transmission, owner. Tipe data integer: year, selling_price, km_driven.
"""

cars.info()

"""## **Memeriksa nilai statistika deskriptif pada dataset**
Statistika deskriptif digunakan untuk menggambarkan/summary dataset. Seperti : nilai mean, median, modus, variance, standar deviasi, quartile, range dan sejenisnya. Untuk melihat nilai-nilai tersebut maka digunakan method describe() . Dapat dilihat bahwa pada nilai min/minimum tidak terdapat angka 0 yang artinya tidak terdapat missing value.


"""

cars.describe()

"""## **Memeriksa apakah terdapat nilai missing value pada setiap kolom data**
Dengan memanggil method isnull() serta menambahkan method sum() kita bisa tau jumlah missing value pada tiap kolom data. Dan ternyata masing-masing kolom jumlah missing valuenya adalah 0 atau tidak terdapat nilai missing value

"""

cars.isnull().sum()

"""## **Memeriksa apakah terdapat outlier dengan visualisai**
Nilai outliers merupakan data yang menyimpang terlalu jauh dari data yang lainnya dalam suatu rangkaian data (pencilan). Nilai pencilan ini dapat menyebabkan distorsi terhadap nilai yang asli.

Untuk melihat outlier dapat menggunakan visualisasi dengan boxplot, pada visualisasi di bawah ini nilai outlier dapat dilihat sebagai titik-titik di luar batas minimum/maksimum

"""

sns.boxplot(x=cars['year'])

sns.boxplot(x=cars['km_driven'])

"""## **Menangani Outlier Menggunakan Interquartile**
Dengan menggunakan interquartil, nilai pencilan yang melebihi nilai Quartil 1 (Q1) akan diubah menjadi nilai Q1. Sementara itu, nilai pencilan yang kurang dari nilai Quartil 3 (Q3) akan diubah nilainya menjadi nilai Q3. kemudian membuat variabel batas atas dan batas bawah karena outlier berada diluar jangkauan itu. Kemudian yang terakhir menyaring data-data yang ada pada rentang batas bawah - batas atas sehingga outlier yang berada di luar batas bawah - batas atas tidak disertakan.
"""

Q1 = cars.quantile(0.25)
Q3 = cars.quantile(0.75)

IQR=Q3-Q1

batas_bawah = Q1 - 1.5 * IQR
batas_atas = Q3 + 1.5 * IQR
cars=cars[~((cars<(batas_bawah))|(cars>(batas_atas))).any(axis=1)]
 
# Cek ukuran dataset setelah kita drop outliers
cars.shape

"""## Univariate Analysis
Membagi fitur pada dataset menjadi dua bagian, yaitu numerical features dan categorical features.
"""

numerical_features = ['selling_price', 'year', 'km_driven']
categorical_features = ['name', 'fuel', 'seller_type', 'transmission', 'owner']

"""## Categorical Features"""

feature = categorical_features[0]
count = cars[feature].value_counts()
percent = 100*cars[feature].value_counts(normalize=True)
df = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(df)
f = plt.figure()
f.set_figwidth(150)
f.set_figheight(5)
count.plot(kind='bar', title=feature);
f = plt.figure()

"""Pada grafik di atas terdapat ratusan kategori, namun terdapat 5 kategori pada fitur name, secara berurutan dari jumlahnya yang paling banyak yaitu: Maruti Swift Dzire VDI, Maruti Alto 800 LXI, Maruti Alto LXi, Hyundai EON Era Plus, dan Maruti Alto LX. Dapat disimpulkan bahwa lebih dari 3 % mobil yang dijual berjenis Maruti series."""

feature = categorical_features[1]
count = cars[feature].value_counts()
percent = 100*cars[feature].value_counts(normalize=True)
df = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(df)
count.plot(kind='bar', title=feature);

"""Berdasarkan deskripsi variabel, urutan kategori Jenis bahan bakar pada mobil kendaraan banyak digunakan yaitu berjenis Petrol dan Diesel. Kemudian untuk tipe mobil yang menggunakan listrik adalah yang paling sedikit."""

feature = categorical_features[2]
count = cars[feature].value_counts()
percent = 100*cars[feature].value_counts(normalize=True)
df = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(df)
count.plot(kind='bar', title=feature);

"""Berdasarkan informasi dari deskripsi variabel, fitur jenis penjuallan terdiri 3 kategori yaitu individual, Dealer, Trustmark Dealer. Dapat didimpulkan pula bahwa kebanyakan mobil bekas dijual secara perorangan (individual)"""

feature = categorical_features[3]
count = cars[feature].value_counts()
percent = 100*cars[feature].value_counts(normalize=True)
df = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(df)
count.plot(kind='bar', title=feature);

"""Berdasarkan informasi dari deskripsi variabel bahwa mobil bekas yang dijual kebanyakan menggunakan transmisi manual ketimbang transmisi otomatis."""

feature = categorical_features[4]
count = cars[feature].value_counts()
percent = 100*cars[feature].value_counts(normalize=True)
df = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(df)
count.plot(kind='bar', title=feature);

"""Pada visualisasi diatas menunjukan seberapa banyak jenis mobil yang dijual bekas orang ke- sekian dan juga bekas mobil untuk latihan. Dapat disimpulkan  bahwa mobil bekas dengan orang pertama (pemilik pertama) yang dijual paling banyak selain pemilik ketimbang pemilik ke 2,3,4 dan seterusnya. Kemudian mobil bekas latihan paling sedikit tersedia.

#### Numerical Features
"""

cars.hist(bins=50, figsize=(20,15))
plt.show()

"""Berdasarkan visualisasi histogram di atas kita dapat beberapa insight yaitu :

- Mobil bekas yang paling banyak dijual yaitu mobil pada keluaran tahun 2018,2016, 2012. Kemudian yang paling sedikit yaitu mobil keluaran 2020 dan 2004.
- Peningkatan harga mobil bekas sebanding dengan jumlah mobil yang ada walaupun terdapat kenaikan sedikit.
- Mobil bekas yang dijual paling banyak yaitu mobil yang sudah dipakai dengan kilometer 50000

## Multivariate Analysis

#### Categorical Features
"""

cat_features = cars.select_dtypes(include='object').columns.to_list()
 
for col in cat_features:
  sns.catplot(x=col, y="selling_price", kind="bar", dodge=False, height = 4, aspect = 3,  data=cars, palette="Set3")
  plt.title("Rata-rata 'price' Relatif terhadap - {}".format(col))

"""Dengan mengamati rata-rata harga relatif terhadap fitur kategori di atas, maka kita bisa simpulkan bahwa:
- Pada fitur fuel(jenis bahan bakar) harga paling tinggi yaitu pada kategori Diesel, kemudian diikuti oleh Petrol dan Electric.
- Pada fitur seller_type(tipe penjualan) harga paling tinggi yaitu jika membeli mobil bekas di Trustmark Dealer(Dealer terpercaya) sedangkan harga paling murah jika membeli secara Individual (peorangan) atau dari tangan ke tangan
- Pada fitur transmisi(jenis transmisi pada mobil) dapat dikatakan bahwa mobil dengan transmisi otomatis cenderung lebih mahal dibanding dengan mobil dengan transmisi manual
- Pada fitur owner(pemilik ke-/kepemilikan) dapat disimpulkan bahwa mobil bekas pada mobil yang digunakan untuk pelatihan memiliki harga yang paling tinggi ketimbang mobil yang telah dibeli orang. Kemudian juga semakin mobil bekas itu beralih tangan (pemilik ke1,2,3,4 dsb) maka harga mobil semakin turun.

#### Numerical Features
"""

# Mengamati hubungan antar fitur numerik dengan fungsi pairplot()
sns.pairplot(cars, diag_kind = 'kde')

plt.figure(figsize=(10, 8))
correlation_matrix = cars.corr().round(2)
 
# Untuk menge-print nilai di dalam kotak, gunakan parameter anot=True
sns.heatmap(data=correlation_matrix, annot=True, cmap='coolwarm', linewidths=0.5, )
plt.title("Correlation Matrix untuk Fitur Numerik ", size=20)

"""Pada grafik korelasi matrix di atas antara fitur (year dan km_driven) terhadap target (selling_price) terlihat bahwa tidak terdapat nilai korelasi yang mendekati 0 terhadap target. Nilai korelasi antara fitur year terhadap selling_price yaitu 0.63, dan fitur km_driven terhadap selling_price yaitu -0.28. Jadi tidak perlu ada yang didrop"""

cars.head()

"""# Data Preparation

#### Encoding Fitur Kategori

Karena data yang bisa diproses oleh model adalah data berupa angka maka perlu melakukan proses one-hot encoding yaitu merubahnya menjadi numerik dengan memanfaatkan library Library scikit-learn.
"""

cars = pd.concat([cars, pd.get_dummies(cars['name'], prefix='name')],axis=1)
cars = pd.concat([cars, pd.get_dummies(cars['fuel'], prefix='fuel')],axis=1)
cars = pd.concat([cars, pd.get_dummies(cars['seller_type'], prefix='seller_type')],axis=1)
cars = pd.concat([cars, pd.get_dummies(cars['transmission'], prefix='transmission')],axis=1)
cars = pd.concat([cars, pd.get_dummies(cars['owner'], prefix='owner')],axis=1)
cars.drop(['name', 'fuel', 'seller_type', 'transmission', 'owner'], axis=1, inplace=True)
cars.head()

"""#### Train-Test-Split

Pada proses split dataset yaitu menggunakan proporsi 0.2 engan fungsi train_test_split dari sklearn. Split dataset menjadi data train dan data test sebelum transformasi dilakukan supaya transformasi diterapkan hanya pada data latih.
"""

X = cars.drop(["selling_price"],axis =1)
y = cars["selling_price"]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 123)

"""**Menampilkan total dataset secara keseluruhan, total dataset latih, total dataset uji**"""

print(f'Total # of sample in whole dataset: {len(X)}')
print(f'Total # of sample in train dataset: {len(X_train)}')
print(f'Total # of sample in test dataset: {len(X_test)}')

"""#### Standarisasi 
StandardScaler yaitu proses standarisasi fitur dengan mengurangkan mean (nilai rata-rata) kemudian membaginya dengan standar deviasi untuk menggeser distribusi. Kemudian menghasilkan distribusi dengan standar deviasi sama dengan 1 dan mean sama dengan 0. Untuk pertama kali yang akan dilakukan standarisasi yaitu pada data latih, Tujuannya adalah menghindari kebocoran informasi pada data uji.
"""

numerical_features = ['year', 'km_driven']
scaler = StandardScaler()
scaler.fit(X_train[numerical_features])
X_train[numerical_features] = scaler.transform(X_train.loc[:, numerical_features])
X_train[numerical_features].head()

""" mengecek nilai mean dan standar deviasi pada setelah proses standarisasi"""

X_train[numerical_features].describe().round(4)

"""# Model Development

Menyiapkan dataframe untuk analisis model
"""

models = pd.DataFrame(index=['train_mse', 'test_mse'], 
                      columns=['KNN', 'RandomForest', 'Boosting'])

"""#### KNN
cara kerja algoritma KNN yaitu memprediksi nilai dari setiap data yang baru menggunakan pendekatan "kesamaan fitur". Dengan kata lain, setiap data baru diberi nilai berdasarkan seberapa mirip titik tersebut dalam set pelatihan.
"""

knn = KNeighborsRegressor(n_neighbors=10)
knn.fit(X_train, y_train)
 
models.loc['train_mse','knn'] = mean_squared_error(y_pred = knn.predict(X_train), y_true=y_train)

"""#### Random Forest
Random forest merupakan model prediksi yang terdiri dari beberapa model dan bekerja secara bersama-sama
"""

# buat model prediksi
RF = RandomForestRegressor(n_estimators=50, max_depth=16, random_state=55, n_jobs=-1)
RF.fit(X_train, y_train)
 
models.loc['train_mse','RandomForest'] = mean_squared_error(y_pred=RF.predict(X_train), y_true=y_train)

"""#### Boosting Algorithm
Boosting Algorithm yaitu model bekerja dengan membangun model dari data latih kemudian ia membuat model kedua yang bertugas memperbaiki kesalahan dari model pertama. Model ditambahkan sampai data latih terprediksi dengan baik atau telah mencapai jumlah maksimum model untuk ditambahkan
"""

boosting = AdaBoostRegressor(learning_rate=0.05, random_state=55)                             
boosting.fit(X_train, y_train)
models.loc['train_mse','Boosting'] = mean_squared_error(y_pred=boosting.predict(X_train), y_true=y_train)

"""melakukan scaling terhadap fitur numerik pada X_test sehingga memiliki rata-rata=0 dan varians=1"""

X_test.loc[:, numerical_features] = scaler.transform(X_test[numerical_features])

"""**Evaluasi ketiga model dengan metrik MSE**"""

mse = pd.DataFrame(columns=['train', 'test'], index=['KNN','RF','Boosting'])
 
model_dict = {'KNN': knn, 'RF': RF, 'Boosting': boosting}
 
for name, model in model_dict.items():
    mse.loc[name, 'train'] = mean_squared_error(y_true=y_train, y_pred=model.predict(X_train))/1e3 
    mse.loc[name, 'test'] = mean_squared_error(y_true=y_test, y_pred=model.predict(X_test))/1e3
 
mse.round(4)

fig, ax = plt.subplots()
mse.sort_values(by='test', ascending=False).plot(kind='barh', ax=ax, zorder=3)
ax.grid(zorder=0)

"""Berdasarkan gambar di atas, terlihat model Random Boosting Algorithm memberikan nilai eror yang paling kecil. Dan model dengan Random Forest juga memiliki eror tidak jauh berbeda namun berpotensi mengalami over fitting. Sedangkan model KNN memiliki nilai error yang paling besar."""

prediksi = X_test.iloc[:1].copy()
pred_dict = {'y_true':y_test[:1]}
for name, model in model_dict.items():
    pred_dict['prediksi_'+name] = model.predict(prediksi).round(1)
 
pd.DataFrame(pred_dict)

"""Hasil prediksi yang paling mendekati nilai asli yaitu dengan menggunakan algoritma Bossting."""

